

# 네트워크

| 순서 | 날짜     | 제목                                                |
| ---- | -------- | --------------------------------------------------- |
| 1    | 21/07/09 | [1, 2장 네트워크와 모델](1,-2장-네트워크와-모델.md) |
| 2    | 21/07/10 | [3장-L2-이더넷](3장-L2-이더넷.md)                   |
| 3    | 21/07/12 | [4장-L3-IP-주소](4장-L3-IP-주소.md)                 |
|      |          |                                                     |
|      |          |                                                     |
|      |          |                                                     |
|      |          |                                                     |
|      |          |                                                     |
|      |          |                                                     |
|      |          |                                                     |



# Network & Web

# Web

1. AJAX란 무엇이며 왜 사용하는지 설명하시오
   - 비동기 통신을 위한 JavaScript 라이브러리 입니다.
   - **A**synchronous **J**avascript **A**nd **X**ml(비동기식 자바스크립트와 xml)
   - 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술

2. GET 방식과 POST 방식의 차이점을 설명하시오.

3. REST란 무엇이고, RESTful하게 API를 디자인한다는 것은 무엇인지 설명하시오.

   - Restful하게 API를 디자인한다는 것은 URI를 규칙에 맞게 잘 설계했는지의 여부

     1. 동일한 URI(End point)의 행위에 맞게 POST, GET, DELETE, PATCH등의 메소드를 사용한다.
     2. 명사를 사용한다. 리스트를 표현할 때는 복수형을 사용한다.
     3. URI Path에 불필요한 파라미터를 넣지 않는다. 즉, 단계를 심플하게 설계한다.

4. Session과 Cookie에 대해 설명하시오
   - HTTML의 비연결성 (Connectionless), 비상태성 (Stateless) 보완
   - 비연결성 : 클라이언트가 서버에 요청(request)을 했을 때, 그 요청에 맞는 응답(response)을 보낸 후 연결을 끊는 처리방식
   - 비상태성 : 클라이언트와 서버가 통신으로 데이터를 주고받아도 두번째 통신에서는 이전 데이터를 유지하지 않는다.
   - 쿠키: 사용자의 웹 브라우저 (클라이언트 PC)에 저장하는 데이터. text 형식으로 저장됨
     - 만료 시점이 지나야 삭제됨, 세션보다 빠름
   - 세션: 웹 서버에 object 형식으로 저장됨. 
     - 브라우저 종료 시 삭제, 쿠키보다 느림

<br>



# Network

#### ◼ OSI 7계층

1. 물리 : 데이터를 전기적 신호로 변환하여 전송
2. 데이터링크 :같은 LAN선 안에서 MAC 주소로 통신한다.
3. 네트워크 : 라우팅, 다른 LAN선에 있는 컴퓨터에 라우팅을 통해 IP 주소로 통신한다.
4. 전송 
   1. 목적지에 **신뢰**할 수 있는 데이터 전달
   2. **오류** 점검 : 오류 발생 시 재전송 요청
   3. 전송된 데이터의 목적지가 어떤 어플리케이션인지 식별 (**host간** 전송)
   4. 전송 계층 구분
      - TCP (Transmission Control Protocol) : 신뢰성, 연결형 
      - UDP (User Datagram Protocol) : 비신뢰성, 비연결형, 효율성, 실시간
5. 세션 : 논리적 연결 유지 & 해제
6. 표현 
7. 응용

##### ◼ 캡슐화와 역캡슐화란?

- 캡슐화 : 응용 계층부터 물리 계층까지, 계층별로 데이터를 전달할 때 헤더를 붙이는 것
- 역캡슐화 : 데이터 수신 측에서 물리 계층부터 응용 계층까지 계층별로 데이터를 전달할 때 헤더를 제거하는 것

<br>

## L3 네트워크 계층

##### ◼ IP 헤더와 IP 패킷 

- IP 헤더 : 출발지 IP 주소, 목적지 IP 주소 등
- IP 패킷 : IP 프로토콜을 사용해 캡슐화 할 때 데이터에 IP 헤더가 추가된 것 cf) 2계층 - 프레임

##### ◼ IP 주소의 구조

- IPv4 (32) 주소 고갈 문제를 위해 IPv6 (128)과 혼용하여 사용, 공인/사설 IP 나누어 할당
  - <u>공인 IP</u> : 라우터에 ISP (인터넷 서비스 제공자)가 제공
  - <u>사설 IP</u> : 랜 안에 있는 컴퓨터에 랜의 네트워크 관리자가 할당 or DHCP로 자동 할당
- cf> MAC 주소 (48) 16진수, IP 주소 (32) 10진수로 표기
  - IP주소를 32개의 2진수 (비트)로 표기할 때 8개씩 나눠서 표기 -> 옥텟 (octet)
- IP 주소는 네트워크 ID와 호스트 ID로 나뉜다.
  - <u>네트워크 ID</u> : 어떤 네트워크인지
  - <u>호스트 ID</u> : 해당 네트워크의 어느 컴퓨터인지

##### ◼ IP 주소의 클래스 구조

- IPv4는 32비트인데 네트워크 ID를 조절하여 쓸 수 있고 네트워크 크기를 클래스라는 개념으로 구분한다.
- 클래스별로 공인 IP, 사설 IP로 사용할 수 있는 주소가 분리되어 정해져 있다.
- A 클래스 : 대규모, 네트워크 ID 8 + 호스트 24 
- B 클래스 : 중형, 네트워크 ID 16 + 호스트 16
- C 클래스 : 소규모, 네트워크 ID 24 + 호스트 7
- D클래스 : multicast 주소
- E 클래스 : 연구 및 특수용도 주소

##### ◼ 네트워크 주소와 브로드캐스트 주소

1. 네트워크 주소 : 호스트ID가 모두 0인 주소 ex) 192.168.1. | 0
   - 전체 네트워크의 대표 주소
2. 브로드캐스트 주소 : 호스트ID가 모두 이진수로 1인 주소 ex) 192.168.1. | 255
   - 네트워크 내의 컴퓨터, 장비에게 한 번에 데이터 전송

##### ◼ 서브넷 구조

- 서브네팅 : 호스트 ID로 사용되던 비트를 서브넷 ID로 바꾸어 작은 네트워크로 분할한다.
- 서브넷 마스크 : `네트워크ID+서브넷ID`와 `호스트ID 식별`
  - A클래스 : 255.0.0.0
  - B클래스 : 255.255.0.0
  - C클래스 : 255.255.255.0
- prefix 표기법 : 서브넷 마스크를 `슬래시(/비트수)`로 나타냄.
- ex) <u>C클래스에서 4bit 서브네팅</u>
  - 원래 C클래스는 네트워크ID 24 + 호스트ID 8
  - 네트워크ID를 28bit로 변경한다. -> 호스트ID에서 4bit를 빌려 서브넷ID로 사용한다. -> NW24 + subnet 4 + host4
  - 서브넷마스크 : 11111111.11111111.11111111.11110000 -> 255.255.255.240 
  - prefix : `/28`

##### ◼ 기본 게이트웨이 (default gateway)

- 다른 네트워크의 컴퓨터의 데이터를 전송할 때 라우터의 IP 주소로 설정하는 네트워크의 출입구
- ex) 192.168.1.0/24 에 속한 컴퓨터가 다른 네트워크로 전송 시 192.168.1.1 (라우터 IP 주소)로 전송

##### ◼ 라우팅 

- 경로 정보를 기반으로 다른 네트워크까지 최적의 경로로 데이터를 전송하는 방식
- 라우팅 테이블 : 라우팅에 사용되는 경로 정보가 저장되어 있는 곳
- 라우팅 프로토콜 (ex. RIP, OSPF, BFP) : 라우터 간 라우팅 정보를 서로 교환하는 프로토콜

<br>

## L4 전송 계층

##### ◼ TCP의 구조

- <span class="evidence">세그먼트</span>: TCP 헤더가 붙은 데이터
- TCP 헤더 : TCP로 전송할 때 붙이는 헤더
  - 출발지 포트 번호(16), 목적지 포트 번호(16), 일련번호(32), 확인 응답 번호(32), 코드 비트(6), 윈도우 크기(16),  체크섬(16) 등
    - 포트 번호 : 데이터 목적지가 어떤 어플리케이션인지 구분
      - 0~1023 : well-kwon ports(서버 측 어플리케이션)
      - 1024 : 예약 (사용x) 
      - 1025~ : 랜덤 포트 (클라이언트 송신 포트)  
    - 코드 비트 : SYN, ACK, FIN, 초기화 0, 활성화 1, 데이터 전송 전 연결 성립과 해제를 위해
    - 세그먼트(데이터) 하나를 보낼 때 마다 반환되는 일련번호, 확인 응답 번호를 통해 <span class="evidence">재전송 제어</span>
      - 일련번호 : <u>송신측에서</u> 수신측에 이 데이터가 몇 번째 데이터인지 알려준다. 
      - 확인 응답 번호 : <u>수신측이</u> 송신 측에 몇 번째 데이터를 수신했는지 알려준다.
    - 윈도우 크기 : 세그먼트를 버퍼에 저장하며 연속해서 보내고 확인 응답을 반환한다. 이때 버퍼의 한계 크기가 윈도우 크키고 버퍼가 넘치면 overflow가 발생한다. 
  - TCP 헤더는 목적지까지 데이터를 제대로 전송하기 위해 필요한 정보를 가지고 있다.
- TCP가 데이터를 전송하려면 `연결(connection)`이라는 가상의 독점 통신로를 확보한 후 데이터를 전송한다.

##### ◼ TCP 3 way handshake - 연결(connection) 성립 : TCP의 정확한 전송 보장을 위해, SYN과 ACK로 연결을 확립한 후 전송한다.

1. 클라이언트가 서버에게 접속을 요청하는 `SYN` 패킷 보낸다. 클라이언트는 응답을 기다린다.
2. 서버가 `SYN` 요청을 받고 요청을 수락한다는 `ACK`와 `SYN`을 보내 클라이언트가 응답하길 기다린다.
3. 클라이언트가 `ACK`를 보내고 연결이 이루어져 데이터가 오간다. 

##### ◼ TCP 4 way handshake - 연결 해제

   1. 클라이언트가 연결을 종료하겠다는`FIN` 플래그 전송
   2. 서버가 `FIN`을 받고 확인했다는 `ACK` 클라이언트를 보낸다. 이때 모든 데이터를 보내기 위해 `TIME OUT` 상태가 된다.
   3. 데이터를 모두 보냈다면 연결이 종료되었다는 `FIN`을 클라이언트에게 보낸다.
   4. 클라이언트가 `FIN`을 받고 확인했다는 `ACK`를 보낸다. 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 클라이언트는 `TIME WAIT`
   5. 서버는 `ACK`를 받은 후 소켓을 닫는다. (`Closed`)
   6. `TIME WAIT` 시간이 끝나면 클라이언트도 닫늗다. (`Closed`)

   ![connection](image/connection.PNG)

##### ◼ TCP 흐름제어/ 혼잡제어

##### ◼ UDP의 구조

- UDP 데이터 그램 : UDP 헤더가 붙은 데이터
- UDP 헤더 : 출발지 포트 번호 (16), 목적지 포트 번호 (16), 길이(16), 체크섬(16)

##### ◼ 브로드캐스트 : UDP는 상대방을 확인x 연속해서 데이터를 보내기 때문에 브로드 캐스트 가능, 랜에 있는 컴퓨터나 네트워크 장비에 데이터를 일괄로 보낸다.

##### ◼ 애플리케이션과 포트 번호

- 22 SSH, 25 SMTP, 53 DNS, 80 HTTP, 110 POP3, 443 HTTPS

<br>

## L7 응용 계층

##### ◼ HTTP와 HTTPS의 차이 : 백엔드에서 프론트로 데이터를 전송할 때 데이터 암호화의 유무이다.

- 암호화 방식은 SSL 인증서다.
