# 페이징과 세그먼테이션

> 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 이해 <u>주기억장치를 동적분할하는 메모리 관리 작업</u>이 필요해서 사용한다.



페이지: logical memory를 동일한 크기로 자름

프레임: 프로세스 physical memory를 페이지에 맞게 동일한 크기로 자른다.

가변분할 : 연속 할당 방식, 프로세스별로 메모리에 할당 -> 외부 단편화 발생

고정 분할: 페이징 -> 내부 단편화 발생



# 페이징

- 외부 단편화 : 프로세스를 연속 할당(Contiguous Allocation)하면 외부 단편화가 발생한다.

- 고정 분할: logical memory를 동일한 크기(Page)로 자르고, physical address도 동일한 크기(Frame)로 잘라서 배치한다 =>  외부 단편화가 발생하지 않는다.
- 연속 할당 방법은 프로세스별로 메모리에 할당하는데 이 프로세스들이 크기가 다 제각각이기 때문에 가변 분할이라고 한다.
- 즉 페이징은 프로세스를 일정 크기인 페이징으로 잘라서 메모리에 적재하는 방식이다.
- 내부 단편화 문제가 발생할 수 있다: 프로세스가 페이지 크기에 딱 맞게 분할되지 않을 수도 있다. 만약 프로세스가 페이지 한 블록의 크키보다 작은 추가적 크기를 가지고 있다면 남는 공간이 발생하고 이를 내부 단편화라 한다.



![Page와Frame](.\img\Page와Frame.JPG)

# 메모리 관리 기법

## 1. 연속 메모리 관리

> 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 함

- **고정** 분할 기법: 주기억장치가 고정된 파티션으로 분할 -> **내부** 단편화 발생
- **동적** 분할 기법: 파티션들이 동적 생성되어 자신의 크기와 같은 파티션에 적재 -> **외부** 단편화 발생

## 2. 불연속 메모리 관리

> 프로그램 일부가 서로 다른 주소 공간에 할당될 수 있는 기법

- **페이지**: **고정** 사이즈의 작은 **프로세스** 조각
- **프레임**: 페이지 크기와 같은 주기억 장치 **메모리** 조각
- 단편화: 기억 장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상
- **세그먼트**: 서로 **다른** 크기를 가진 **논리적** 블록이 연속적 공간에 배치되는 것

고정크기 : 페이징

가변크기: 세그먼테이션



### 단순 페이징

- 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨
- 외부 단편화x
- 소량의 내부 단편화만 존재

### 단순 세그먼테이션

- 각 프로세스는 여러 세그먼트들로 나뉨
- 내부 단편화x, 메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소
- 외부 단편화 존재

### 가상 메모리 페이징

- 단순 페이징과 비교해 페이지 전부를 로드시킬 필요x
- 필요한 페이지가 있으면 나중에 자동으로 불러들어짐
- 외부단편화x
- 복잡한 메모리 관리로 오버헤드 발생

### 가상 메모리 세그먼테이션

- 필요하지 않은 세그먼트들은 로드되지 않음
- 필요한 세그먼트 있을 때 나중에 자동으로 불러들어짐
- 내부단편화x
- 복잡한 메모리 관리로 오버헤드 발생