## 운영체제

- 컴퓨터 자원을 효율적으로 관리하는 시스템 소프트웨어다.
- 발전: 일괄처리 -> 다중 프로그래밍 (1CPU) -> 온라인 -> 시분할 처리 -> 실시간 처리 -> 다중 모드 처리 (N CPU) -> 분산 처리 -> 병렬 처리

## 커널/ 쉘 / 시스템 콜

1. Kernel
   1. 제어 프로그램
   2. 운영체제 핵심
   3. 하드웨어 제어
   4. 각종 시스템 자원 관리 및 스케줄링
2. Shell
   1. 명령어 해석기
   2. 사용자와 시스템 간의 인터페이스 담당
3. System Call
   - 시스템 호출: 응용 프로그램 요청에 따라 커널에 접근하기 위한 인터페이스

## Process

- 프로세스는 메모리에 올라와 실행되고 있는 프로그램
- 최소 하나의 스레드를 보유
- 별도의 주소 공간을 독립적으로 할당받는다. (`code`, `data`, `heap`, `stack`)
- 프로세스들은 독립적이기 때문에 통신을 위해 `IPC` 사용

## Process 메모리 공간

1. `stack`: 함수 관련, temporary data (function parameters, return address, local variables)
2. `heap`: `dynamically` allocated during process `runtime`
3. `data` : global variables
4. `text`: 명령어 집합

![Process구조.JPG](https://github.com/jhk828/CS/blob/master/img/Process%EA%B5%AC%EC%A1%B0.JPG?raw=true)

## Thread

- 스레드는 프로세스 안에서 실행되는 흐름 단위

- 같은 그룹의 스레드는 프로세스의 자원과 상태 공유 (코드, 데이터, 파일)

- 반면 스택 & 레지스터는 각각 가지고 있다.

- Stack을 분리한 이유는 Stack에는 함수의 호출 정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위함이다.

- 사용자 수준 스레드 : 사용자가 만든 라이브러리를 사용하여 스레드를 운용, 속도는 빠르지만 구현이 어렵다.

- 커널 수준 스레드: 운영체제의 커널에 의해 스레드를 운용, 구현은 쉽지만 속도가 느리다.

  

## Process State와 상태 변환

1. `new` (생성) : 프로세스의 작업 공간인 메인 메모리에 생성되고 운영 체제 내부에 PCB가 만들어진다. (PCB는 프로세스 실행 정보를 관리하기 위해 생성됨)
2. `ready`(준비) : MM에서 프로세서에(CPU)게 할당 받기를 기다린다.
3. `running` : 프로세서를 점유하여 명령어들이 실행된다.
4. `waiting` (대기) :  이벤트 (I/O 종료 등 외부 신호)가 일어나길 기다린다.
5. `terminated` : 프로세스 수행이 끝난다. 할당된 자원을 OS에 돌려주고 관련 PCB가 삭제된다.

1. Process 상태 변환

   1. `dispatching`: ready 프로세스는 scheduler dispatcher에 의해 프로세서가 부여되어 running 상태가 된다. (ready -> running)

   2. `time run out` : 어떤 프로세스가 프로세서를 독점하는 것을 막기 위해 운영체제는 인터럽트 클록을 두어 지정된 시간 동안만 프로세스가 프로세서를 점유하도록 만든다. (running -> `ready`)

   3. `block`: running 프로세스가 지정된 시간 이전에 입출력 연산 등을 필요로 할 경우 그 프로세스는 스스로 프로세서를 양도한다. (running-> `waiting`)

   4. `wakeup` : 입출력 작업이 끝나면 대기 상태의 프로세스는 준비 상태로 변한다. (waiting -> ready)

   ![ProcessState.JPG](https://github.com/jhk828/CS/blob/master/img/ProcessState.JPG?raw=true)

   

## PCB

- Process Control Block, 프로세스 제어 블록
- 프로세스를 생성할 때 만들어지며, 주기억장치에 유지되며, 실행이 종료되면 같이 삭제된다
- 문맥전환 등 다른 프로세스를 처리해야 할 때 PCB에 현재 상태를 저장하고 그 작업 상태를 불러와 작업 재개가 가능해진다.
- 구성 (13가지)
  - 프로세스 식별자, 프로세스 현재 상태, PC(프로그램 카운터), 프로세스 우선순위,
  - 프로세스가 적재된 기억장치를 가리키는 포인터, 프로세스에 할당된 자원을 가리키는 포인터,
  - CPU 레지스터 정보, CPU 레지스터를 가리키는 포인터, CPU 사용시간 정보,
  - 기억장치 관리 정보, 입출력 정보, 부모 프로세스를 가리키는 포인터, 자식 프로세스를 가리키는 포인터



## 멀티 스레드

- 하나의 응용 프로그램을 여러 개의 스레드로 구성하고, 각 스레드로 하여금 하나의 작업을 처리하도록 한다.
- 웹 서버는 대표적인 멀티 스레드 응용 프로그램이다.

### 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?

- 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 감소함
- 프로세스 간의 통신 (IPC)보다 스레드 간의 통신 비용이 적다
- 대신 멀티 스레드 사용 시 공유 자원으로 인한 문제 해결을 위해 동기화에 신경써야 한다.

### 멀티 프로세싱과 멀티 프로그래밍의 차이는?

- 멀티 프로세싱은 여러 개의 처리 장치 (CPU)를 장착하여 동시에 여러 작업을 병렬로 실행한다.
- 멀티 프로그래밍은 다수 개의 프로그램이 같이 주기억장치에 있도록 한 방식
- CPU 코어의 관점에서 생각
  CPU 코어 여러개로 프로세스를 여러개 수행한다 -> 멀티 프로세싱
  CPU 코어 하나로 프로세스를 여러개 수행한다 -> 멀티 프로그래밍
  CPU 코어 몇 개를 쓰던 간에 작업을 수행한다 (프로세스보다 확장된 의미) -> 멀티 태스킹



## 스케줄러 3개

1. 장기 스케줄러 (잡 스케줄러) : 디스크 공간에 제출된 프로세스들을 선택하여 MM로 적재
2. 단기 스케줄러 (CPU 스케줄러) : CPU와 메모리 사이에서 Ready Queue에 있는 프로세스 중 어떤 것을 CPU 할당을 받게 할지 스케줄링
3. 중기 스케줄러 (Swapper) : 여유공간 부족 시 공간을 만들기 위해 메모리에서 쫓아내어 디스크로 옮김, 동시에 메모리가 많이 올라가는 것을 조절

### Queue 세가지

- Job Queue : 현재 시스템 안에서 돌고 있는 프로세스의 집합
- Ready Queue : 메모리 안에서 CPU의 할당을 기다리는 프로세스의 집합
- Device Queue : 장치 입출력을 기다리고 있는 프로세스의 집합



## Dispatcher

- CPU 제어권을 CPU 스케줄링에 의하여 선택된 프로세스에게 넘겨주는 모듈
- 기능 3가지
  1. 문맥 교환 (Context Switching)
  2. 사용자 모드 (User Mode)로 전환
  3. 사용자 프로그램의 재시작을 위해 해당 주소로 이동-



## Context Switching

- 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정

- 다중 프로그래밍 시스템에서 CPU가 할당되는 프로세스를 변경하기 위해, 현재 CPU를 사용하는 프로세스 상태 (`Context`) 정보를 저장하고, 제어권을 인터럽트 서브 루틴(`ISR`)에게 넘기는 작업

- 특징

  - CPU를 점유하고 있는 프로세스가 변할 때 발생 (준비-실행, 실행-준비, 실행-대기 상태만)
  - 오버헤드가 발생하게 되는데, 불필요한 문맥 교환 발생은 가능한 방지하는 것이 좋음
  - 컨텍스트 스위칭 시 CPU는 아무런 작업을 하지 못한다. 따라서 잦은 컨텍스트 스위칭은 성능 저하를 일으킴.

- 변환 과정 (사용자 모드는 프로세스를 실행, 커널 모드는 인터럽트 처리)

  - 사용자 모드: 프로세스를 실행하는 부분
  - 커널 모드
    1. 이전 프로세스 상태를 PCB에 저장
    2. 다음에 실행할 프로세스 선택
    3. PCB로부터 정보를 얻어 CPU에 저장한 후 사용자 모드로 전환 (디스패처 역할)

  

## 인터럽트란?

- CPU가 프로세스를 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요함을 CPU에게 알리는 것
- 인터럽트 종류
  - I/O Request : 입출력 요청
  - Time Slice Expired : CPU 사용시간 만료
  - Fork Child : 자식 프로세스 생성
  - Wait for interrupt : 인터럽트 처리 대기



## [CPU 스케줄링](https://github.com/jhk828/CS/blob/master/img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81.JPG)

- CPU와 같은 자원을 우선순위에 기반하여 프로세스에 할당하는 방법을 말한다

### 비선점 ( Non-Preemptive) 스케줄링

일괄처리방식에 적당, 문맥교환이 적어 오버헤드가 적다

1. `FIFO(First Input First Output)`: 먼저 입력된 작업을 먼저 처리하는 방식
2. `SJF(Shortest Job First)`
   - 실행 시간 추정치가 가장 작은 작업을 먼저 처리하는 방식
   - `무한 연기` 현상 발생
   - `Aging 기법`(오래 기다린 것을 우선적으로 해결)
3. `HRN(Highest Response-Ratio Next)`
   - 서비스 시간과 대기 시간의 비율을 고려한 스케줄링 방법
   - **우선순위 = (대기시간 + 서비스 시간) / 서비스 시간**
4. 우선순위 스케줄링: 대기 리스트에 있는 프로세스들에게 작업의 우선순위를 부여하여 CPU를 할당하는 방법
5. 기한부 스케줄링: 제한된 시간 내에 반드시 작업이 완료되도록 스케줄링하는 방식

### 선점  스케줄링

- 프로세스가 CPU에 할당되면 우선순위가 높으면 뺏을 수 있음
- 대화형/ 시간분할/ 실시간 시스템에 적당, 문맥교환이 많아 오버헤드가 많다
- 선점- `RR`, `SRT`, `MFQ`, `MQ`

1. `Round Robin)`
   - 시분할 시스템에 의해 고안됨
   - 시간 할당량만큼씩 CPU를 사용하는 방법
2. `SRT(Shortest Remaining Time)`
   - 작업이 '남아 있는' 실행시간의 추정치가 가장 작은 프로세스를 먼저 실행
   - 새로 입력되는 작업까지 포함
3. `MFQ(Multi level Feedback Queue)`
   - 여러 개의 큐가 있으며 짧은 작업이나 입출력 위주의 작업에 우선권을 부여하기 위해 개발된 방식
   - 큐마다 시간 할당량이 존재하며 낮은 큐일수록 시간 할당량이 커지는 방식
   - I/O 위주의 작업이 먼저 실행 (CPU 사용시간이 적다)
4. `MQ(Multi level Queue)`
   - 여러 개의 큐가 있으며 위에 있는 것이 가장 우선순위가 높은 방식
   - 각각의 큐는 각자 고유의 알고리즘을 사용한다
   - 높은 우선순위의 큐에 프로세스가 들어오면 먼저 실행하는 선점 방식을 채택한다



## 프로세스 동기화

- 정의 : 상호배제 원리를 보장하는데 사용되는 방법, 프로세스에 대한 처리 순서 결정 방법
- `Semaphore` : 프로세스들이 임계영역에 접근하기 위해 두 연산자 `P (Wait)` & `V (Signal)`를 통해 동기화 유지
- `Monitor`: 운영체제 내부의 프로그램으로서 프로세스들의 공유 자원 순서 제어



### 뮤텍스와 세마포어 차이점은?

- 뮤텍스는 Locking 메커니즘. 락을 건 쓰레드만이 임계 영역을 나갈 때 락 해제 가능
- 세마포어는 Signaling 메커니즘. 락을 걸지 않은 쓰레드도 sinal을 사용하여 락 해제 가능
  - 세마포어 카운트 = 1 설정 시 뮤텍스처럼 사용 가능
- 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다.
- 세마포어는 소유 불가능하지만 뮤텍스는 소유가 가능하다.
- 동기화의 개수가 다르다.



## 임계영역 문제

- 프로세스 구성: 코드/ 데이터/ 스택 영역으로 구분, 공유 메모리에 접근하는 코드가 임계 영역
- 잔류 영역 : 아래 3개 영역 제외한 나머지 부분
- 진입 영역 : 임계 영역으로의 진입을 요청하는 부분
- 임계 영역 : 공유 자원에 공유하는 코드
- 출구 영역 : 임계 영역에 빠져 나왔음을 알리는 영역



### 임계 영역 요구 조건 3가지

1. 상호 배제 (Mutual Exclusion) : 두 개 이상의 프로세스가 동시에 임계영역에 존재할 수 없다.
2. 진행 (Progress) : 현재 임계 구역에서 실행되는 프로세스가 없는 경우, 잔류 영역에 이외에 있는 프로세스는 임계 영역에 진입할 수 없다.
3. 한계 대기 (Bounded Waiting) : 한 프로세스가 임계 영역에 대한 진입 요청 후, 일정 시간 내에 진입을 허락해야 한다.



## Race Condition

- 두 개의 스레드가 하나의 자원을 놓고 서로 사용하려고 경쟁하는 상황
- 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 실행 순서를 조절해주지 않으면 결과값에 영향을 줄 수 있다.



## 상호 배제 (SW 동기화)

1. Dekker 알고리즘 (엄격한 교대) : `flag`와 `turn`이라는 변수로 임계 영역에 들어갈 프로세스를 결정하는 방식
   - `flag` : 프로세스 중 누가 임계 영역에 진입할 것인지 나타냄
   - `turn`: 누가 임계 영역에 들어갈 차례인지
2. Peterson 알고리즘: `flag`와 `turn` 변수를 사용하여 프로세스가 임계구역에 들어가는 것을 구분, 상대방에게 진입기회를 양보한다는 차이가 있다.
3. Bakery 알고리즘: 위와 달리 여러 개의 프로세스 혹은 스레드에 대한 처리가 가능, 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계영역에 진입

## 상호 배제 (HW 동기화)

1. Test and Set 명령어 기법
2. Swap 명령어 기법



## 모니터

- 상호 배제를 위한 데이터 및 프로그램 모듈로, 운영체제 내부의 프로그램을 모니터라고 한다.
- 두개 이상의 프로세스가 특정 공유 자원을 순차적으로 할당하는데 필요한 데이터 및 프로시저를 포함하는 병행성 구조
- 모니터 내의 자원을 원하는 프로세스는 반드시 해당 모니터의 진입부 (진입 영역)를 호출
- 모니터 외부의 프로세스는 모니터 내부의 데이터를 직접 접근할 수 없다.
- 자료 추상화와 정보 은폐 개념을 기초적으로 사용
- 모니터에 사용되는 연산은 Wait와 Signal



## 바쁜 대기와 스핀락

1. Busy Waiting : 임계 영역에 들어갈 수 있을 때 까지 아무 작업도 하지 않고 무한으로 기다리고 있는 현상 (ex. Dekker 알고리즘)
2. Spinlock : 임계구역에 진입이 불가능할 때 진입이 가능할 때 까지 루프를 돌면서 재시도하는 방식으로 구현된 락



## 교착상태

- 한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황
- 프로레스가 자원을 얻기 위해 영구적으로 기다리는 상태

### 교착상태 발생 조건

1. Mutual Exclusion 상호배제 : 한 자원은 한번에 한 프로세스만 사용 가능
2. Hold and Wait 점유 대기: 프로세스는 자원이 할당된 상태에서 다른 자원이 할당되기를 기다린다.
3. No preemption 비선점 : 다른 프로세스가 사용 중인 자원을 선점하여 사용할 수 없다.
4. Circular Wait 환형 대기: 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있다.

### 교착상태 해결법

1. 예방 : 4가지 조건 중 하나를 제거해서 데드락을 미리 예방
2. 회피 : 자원이 어떻게 요청될지에 대한 정보를 미리 알아서, 데드락에 빠질 가능성이 있는지 운영체제가 검사를 해서 빠질 가능성이 없을 대만 자원을 할당하여 문제를 회피한다.
   - 은행원 알고리즘 : 프로세스가 자원을 요구할 때 시스템이 안정 상태를 유지할 수 있는 프로세스의 자원 요구만을 할당해주는 방안
   - 자원 할당 그래프 알고리즘 
3. 발견 & 회복 : 교착 상태가 해결될 때 까지 한 프로세스씩 중지
   - 운영체제가 요청하는 자원을 모두 주고 주기적으로 데드락에 빠졌는지를 검사한다. 데드락에 빠진 것을 발견 (detect)하면, deadlock에 빠지기 전 상태로 회복(recover)
   - 회복: 교착 상태에 빠진 프로세스를 일시 정지하거나 강제로 종료하여 자원을 반환
4. 무시

### 은행원 알고리즘

- 프로세스가 자원을 요구할 때 시스템이 자원을 할당한 후 안정 상태로 남아있게 되는지를 사전에 검사하여 교착상태를 회피 (Avoidance)

- 단점

  - 사용자의 수가 일정
  - 항상 불안정 상태를 방지해야 하므로 자원 이용도가 낮음
  - 할당할 수 있는 자원의 수가 일정

- 구성

  1. Allocation: 각 프로세스에 할당되어 있는 자원의 수
  2. Max: 각 프로세스의 최대 자원 요구의 수
  3. Available: 유형별 사용 가능한 자원의 수
  4. Need: 각 프로세스가 추가적으로 필요한 자원의 수

  

### 식사하는 철학자 문제

- 다수의 프로세스가 다수의 자원을 할당할 때의 상황을 나타낸 것
- 철학자가 프로세스, 젓가락이 자원
- 운영체제 교착상태 설명하는데 주로 사용되는 문제

### 교착상태 회복 기법

1. 선점 (Preemption)
   - 보유한 자원을 빼앗아 교착상태를 해결하고 시스템을 정상으로 회복하는 방법 (우선순위가 낮거나, 진행 상태가 적거나, 자원을 적게 사용하는 것)
2. 복귀 (**Rollback**) 
   - 교착상태가 발생하기 이전 상태로 복귀하여 다시 실행하는 방법
3. 제거 (Kill) 
   - 우선순위가 낮거나, 진행 상태가 적거나, 자원을 적게 사용하는 프로세스를 선택하여 제거
4. 사용자의 조치 경로 선택(Routing) 
   - 프로세스 리스트를 보고 문제 있는 프로세스를 선택하여 제거하는 방법 (ex. Window의 Ctrl + Alt + Delete)



## 연속 할당 / 분할 할당

1. 연속 할당 : 각 프로그램이 주기억장치 내에 인접되어 연속되게 하나의 블록을 차지하도록 배치되는 방법
2. 분할 할당 : 하나의 프로그램이 페이지나 세그먼트 단위로 나뉘어 분산 배치되는 방법



## 단편화

1. 내부 단편화

   - 정해진 크기에 프로그램을 할당하고 남은 사용되지 못하는 기억 공간 

   - 페이징 시 나타남
   - 해결 : 세그먼트

2. 외부 단편화

   - 정해진 크기x, 실행할 작업보다 많은 메모리 공간이 남아있지만 배치할 수 없는 경우 . 메모리 배치에 따라 발생하는 문제 

   - 세그먼트 시 나타남
   - 해결 : 페이징

- 통합 (Coalescing) : 인접한 공백 (기억 공간)들을 더 큰 하나의 공백으로 만드는 과정, 차폐 레지스터의 값을 변경
- 압축 (Compaction) : 서로 떨어져 있는 여러 개의 낭비 공간을 모아서 하나의 큰 기억 공간을 만드는 과정



## 페이징

- 정의 : 고정된 크기로 / 주기억 장치와 프로그램 분할

- 논리 주소 공간(가상 메모리)를 동일한 크기의 페이지로 자르고, 물리적 주소 공간(RAM)을 동일 크기의 프레임으로 잘라서 배치한다.

- 특징 : **내부** 단편화 발생 (프로그램 마지막 부분 일부분만 되는 것이 특징)

- 페이지 크기 ↑ : 테이블 크기 ↓, MM 공간 절약, 참조되는 정보와 무관한 것이 MM에 남게 됨

- 페이지 크기 ↓ : 테이블 크기↑, Page Mapping Table 공간 더 필요, 자주 사용하는 페이지의 집합을 효율적으로 관리, 기억장치 효율 ↑, 총 I/O 시간 ↑

- 주소의 동적 재배치 허용 : 페이지와 프레임을 대응시키기 위해 page mapping이 필요해서 paging table이 필요하다. (MMU - 메모리 관리장치 필요)

- 페이지 단위에 알맞게 꽉채워 쓰는게 아니므로 내부 단편화 문제는 여전히 있다. 페이지가 클수록 내부 단편화도 커짐. 그러나 페이징 단위를 작게 하면 page mapping 과정이 많아져 오히려 효율이 떨어진다.

  

  

## 세그멘테이션

- 정의 : 프로그램을 여러 개의 **다른 크기**로 분할하고 주기억 장치에서는 분할된 크기에 맞게 **동적으로** 분할하여 적재시키는 방법
- 특징
  - **외부** 단편화 발생
  - 기억장치 보호 키 사용 (프로그램 구분 표시)
  - 사용하지 않는 공간들은 통합과 압축을 통해 메모리 효율화
  - 배치 전략(최초, 최적, 최악 )
- 각 세그먼트는 연속적인 공간에 저장되어 있다. 
- 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다
- mapping을 위해 세그먼트 테이블이 필요하며 각 세그먼트 항목별 세그먼트 시작 주소와 길이 정보를 가지고 있다. 
- 프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부 단편화를 해결할 수 있으나 여전히 중간에 프로세스가 메모리를 해제하면 구멍이 생겨 외부 단편화 문제가 발생한다.



## 메모리 할당 알고리즘

- First fit : 메모리의 처음부터 검사해서 크기가 충분한 첫번째 메모리에 할당
- Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾음
- Best fit : 모든 메모리 공간을 검사해서  <u>내부 단편화를 최소화</u>하는 공간에 할당



## 가상 기억장치

- 정의: 보조기억장치를 주기억 장치처럼 사용하는 것
- 실제 RAM (주기억장치)보다 큰 메모리 영역 제공
- 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상기억장치에 보관해 놓고 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리
- 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식
- 크게 세그먼트 방식과 페이징 방식이 있다.

1. **Overlay** : 분할된 프로그램을 순차적으로 적재하여 실행
2. **Swapping** : 분할된 프로그램들을 교체하여 실행



## 페이지 폴트

- 프로그램에서 접근하려고 하는 페이지가 주기억장치에 있지 않은 경우 발생하는 현상

## 페이지 교체

정의: 주기억장치와 가상기억장치 사이에서의 페이지 교체를 의미하고 총 7가지의 교체 방식이 있다

- OPT : 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 (실현 가능성 희박)
- FIFO : 주기억장치 내에 가장 오래된 페이지와 교체, 타임스태프 사용, 페이지 부재 수가 가장 많음, Belady의 모순이 발생
- LRU (Least Recently Used): **현 시점에서 가장 오랫동안 사용하지 않은 페이지**와 교체, 각 페이지마다 계수기(시간 기억 영역)를 두어 사용
- LFU (Least Fequently Used) : 사용 빈도가 가장 적은 페이지를 교체
- NUR (Not Used Recently) : 최근에 사용하지 않은 페이지를 교체
- PFF(Page Fault Frequently): 작업집합에 존재하는 페이지들을 관찰하여 최근에 자주 사용되고 있지 않은 페이지와 작업집합에 속하지 않은 페이지 중 최근에 자주 사용하는 페이지와 교체하여 교체 효율을 높이는 방법2차 기회: 처음에는 FIFO 방식으로 진행하다가, 많이 사용된 페이지는 1번 면제해주는 방식



## TLB

- 정의: Translation Lookaside Buffer, 가상 메모리 주소를 물리적인 주소로 변환하는 속도를 높이기 위해 사용되는 캐시
- 특징: 최근에 일어난 가상 메모리 주소와 물리 주소의 변환 테이블을 저장,
- CPU가 1차적으로 TLB에 접근하여 탐색, TLB에 존재하지 않으면 MMU 페이지 테이블을 참고MMU (Memory Management Unit) : CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품(메모리 보호, 캐시 관리, 버스 중재 역할)



## Thrashing

- 정의: 하나의 프로세스가 작업 수행 과정 중 지나치게 페이지 부재가 발생함으로 인하여 전체 시스템의 성능이 저하되는 현상
- 즉, 페이지 교체가 많아지면 **페이지 교체만 하다가** 실제 프로그램을 제대로 실행하지 못하게 되는 현상
- 해결책: **다중 프로그래밍의 정도를 낮추기**, 자주 사용하는 페이지들을 주기억 장치에 미리 갖다 놓기



## 작업집합(Working Set)

- 정의: 자주 사용되는 페이지의 집합은 주기억장치에 미리 적재해두면 페이지 부재를 최소화할 수 있고 효율적인 실행 가능



## 메모리 계층

캐시 -> 메모리 -> 하드디스크

