# 운영체제

1. Process와 Thread의 차이

   - 프로세스는 메모리에 올리와 실행되고 있는 프로그램

   - 스레드는 프로세스 안에서 실행되는 흐름 단위

   - 프로세스는 최소 하나의 스레드를 보유하고 있으며, 각각 별도의 주소 공간을 독립적으로 할당받는다. (code, data, heap, stack)

     - 프로세스들은 독립적이기 때문에 통신하기 위해 IPC를 사용해야 한다.

   - 스레드는 프로세스의 코드, 데이터, 힙 영역을 공유하고 별도의 스택 영역을 갖는다.

     - Stack을 분리한 이유는 Stack에는 함수의 호출 정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위함이다.

     ![Process구조.JPG](https://github.com/jhk828/CS/blob/master/img/Process%EA%B5%AC%EC%A1%B0.JPG?raw=true)

2. Process State와 상태 변환

   1. `new` (생성) : 프로세스의 작업 공간인 메인 메모리에 생성되고 운영 체제 내부에 PCB가 만들어진다. (PCB는 프로세스 실행 정보를 관리하기 위해 생성됨)
   2. `ready`(준비) : 프로세서에(CPU)게 할당 받기를 기다린다.
   3. `running` : 프로세서를 점유하여 명령어들이 실행된다.
   4. `waiting` (대기) :  이벤트 (I/O 종료 등 외부 신호)가 일어나길 기다린다.
   5. `terminated` : 프로세스 수행이 끝난다. 할당된 자원을 OS에 돌려주고 관련 PCB가 삭제된다.

3. Process 상태 변환

   1. `dispatching`: ready 프로세스는 scheduler dispatcher에 의해 프로세서가 부여되어 running 상태가 된다. (ready -> running)

   2. `time run out` : 어떤 프로세스가 프로세서를 독점하는 것을 막기 위해 운영체제는 인터럽트 클록을 두어 지정된 시간 동안만 프로세스가 프로세서를 점유하도록 만든다. (running -> ready)

   3. `block`: running 프로세스가 지정된 시간 이전에 입출력 연산 등을 필요로 할 경우 그 프로세스는 스스로 프로세서를 양도한다. (running-> waiting)

   4. `wakeup` : 입출력 작업이 끝나면 대기 상태의 프로세스는 준비 상태로 변한다. (waiting -> ready)

   ![ProcessState.JPG](https://github.com/jhk828/CS/blob/master/img/ProcessState.JPG?raw=true)

   

4. PCB의 뜻과 저장하는 정보에 대해 설명하시오.

   - Process Control Block, 프로세스 제어 블록
   - 프로세스에 대한 중요한 정보를 저장하고 있으며 프로세스 생성 시 만들어지며 주기억장치에 유지된다.
   - 문맥전환 등 다른 프로세스를 처리해야 할 때 PCB에 현재 상태를 저장하고 그 작업 상태를 불러와 작업 재개가 가능해진다.
   - PID, 상태, 다음 명령어 주소가 저장된다.

5. Concurrency(동시성, 병행성)이란 무엇이고 왜 사용하는지 설명하시오.

6. 멀티 스레드란

   - 하나의 응용 프로그램을 여러 개의 스레드로 구성하고, 각 스레드로 하여금 하나의 작업을 처리하도록 한다.
   - 웹 서버는 대표적인 멀티 스레드 응용 프로그램이다.

7. 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?

   - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 감소함
   - 프로세스 간의 통신 (IPC)보다 스레드 간의 통신 비용이 적다
   - 대신 멀티 스레드 사용 시 공유 자원으로 인한 문제 해결을 위해 동기화에 신경써야 한다.

8. 멀티 프로세싱과 멀티 프로그래밍의 차이는?

   - 멀티 프로세싱은 여러 개의 처리 장치 (CPU)를 장착하여 동시에 여러 작업을 병렬로 실행한다.
   - 멀티 프로그래밍은 다수 개의 프로그램이 같이 주기억장치에 있도록 한 방식
   - CPU 코어의 관점에서 생각
     CPU 코어 여러개로 프로세스를 여러개 수행한다 -> 멀티 프로세싱
     CPU 코어 하나로 프로세스를 여러개 수행한다 -> 멀티 프로그래밍
     CPU 코어 몇 개를 쓰던 간에 작업을 수행한다 (프로세스보다 확장된 의미) -> 멀티 태스킹

9. [CPU 스케줄링](https://github.com/jhk828/CS/blob/master/img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81.JPG)

   - 스케줄러란 CPU와 같은 자원을 우선순위에 기반하여 프로세스에 할당하는 방법을 말한다. 그 Queue에는 세 가지가 있다.
   - Job Queue : 현재 시스템 안에서 돌고 있는 프로세스의 집합
   - Ready Queue : 메모리 안에서 CPU의 할당을 기다리는 프로세스의 집합
   - Device Queue : 장치 입출력을 기다리고 있는 프로세스의 집합

10. 스케줄러 종류 세 가지

   - 장기 스케줄러 (잡 스케줄러) : 프로세스가 한꺼번에 많이 올라올 시, 메모리와 디스크 사이에서 메모리에, Ready Queue에 어떤 걸 집어넣을지 결정
   - 단기 스케줄러 (CPU 스케줄러) : CPU와 메모리 사이에서 Ready Queue에 있는 프로세스 중 어떤 것을 CPU 할당을 받게 할지 스케줄링
   - 중기 스케줄러 (Swapper) : 여유공간 부족 시 공간을 만들기 위해 메모리에서 쫓아내어 디스크로 옮김, 동시에 메모리가 많이 올라가는 것을 조절

11. **Context Switching**이란?

    컨텍스트 스위칭이란 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정입니다.

    1)   인터럽트가 발생하면 현재 진행되고 있는 프로세스의 상태 (Context)를 PCB에 저장합니다.

    2)   다음에 실행할 프로세스를 동작시켜 작업을 처리합니다.

    3)   PCB에 저장되었던 프로세스 상태를 복구하여 마저 처리합니다.

12. 인터럽트란?

    - CPU가 프로세스를 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요함을 CPU에게 알리는 것
    - 인터럽트 종류
      - I/O Request : 입출력 요청
      - Time Slice Expired : CPU 사용시간 만료
      - Fork Child : 자식 프로세스 생성
      - Wait for interrupt : 인터럽트 처리 대기
    - 컨텍스트 스위칭 시 CPU는 아무런 작업을 하지 못한다. 따라서 잦은 컨텍스트 스위칭은 성능 저하를 일으킴.

13. 뮤텍스와 세마포어란, 차이점은?

    - 뮤텍스는 Locking 메커니즘. 락을 건 쓰레드만이 임계 영역을 나갈 때 락 해제 가능
    - 세마포어는 Signaling 메커니즘. 락을 걸지 않은 쓰레드도 sinal을 사용하여 락 해제 가능
      - 세마포어 카운트 = 1 설정 시 뮤텍스처럼 사용 가능
    - 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다.
    - 세마포어는 소유 불가능하지만 뮤텍스는 소유가 가능하다.
    - 동기화의 개수가 다르다.

14. Race Condition
    - 두 개의 스레드가 하나의 자원을 놓고 서로 사용하려고 경쟁하는 상황
    - 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 실행 순서를 조절해주지 않으면 결과값에 영향을 줄 수 있다.

15. 교착상태란?

    - 한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황
    - 프로레스가 자원을 얻기 위해 영구적으로 기다리는 상태

16. 교착상태 발생 조건

    1. Mutual Exclusion 상호배제 : 한 자원은 한번에 한 프로세스만 사용 가능
    2. Hold and Wait 점유 대기: 프로세스는 자원이 할당된 상태에서 다른 자원이 할당되기를 기다린다.
    3. No preemption 비선점 : 다른 프로세스가 사용 중인 자원을 선점하여 사용할 수 없다.
    4. Circular Wait 환형 대기: 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있다.

17. 교착상태 해결법

    1. 예방 : 4가지 조건 중 하나를 제거해서 데드락을 미리 예방
    2. 회피 : 자원이 어떻게 요청될지에 대한 정보를 미리 알아서, 데드락에 빠질 가능성이 있는지 운영체제가 검사를 해서 빠질 가능성이 없을 대만 자원을 할당하여 문제를 회피한다.
       - 은행원 알고리즘
    3. 발견 & 회복 : 교착 상태가 해결될 때 까지 한 프로세스씩 중지
       - 운영체제가 요청하는 자원을 모두 주고 주기적으로 데드락에 빠졌는지를 검사한다. 데드락에 빠진 것을 발견 (detect)하면, deadlock에 빠지기 전 상태로 회복(recover)
       - 강제로 프로세스/ 스레드 들 중 하나를 종료시켜서 강제로 자원 할당을 해제한다.
       - 발견 : 자원 할당 그래프, 복구 : 선점, 프로세스 중지 (희생자 선택)
    4. 무시

18. 기아 상태의 뜻과 해결책은?

    기아 상태란 프로세스의 우선 순위가 낮아서 원하는 자원을 할당 받지 못하는 상태다.

    기아상태를 해결하기 위한 Aging 기법은 시스템에서 자원을 기다린 시간에 비례하여 프로세스에게 우선 순위를 부여하는 방법이다.

19. 링커와 로더의 차이점은?

    링커는 소스코드의 실행 가능한 모듈을 생성하고 로더는 모듈을 메모리에 로드한다. (프로그램의 전부 또는 일부를 메모리에 적재한다.)

20. 메모리 계층 : 캐시 -> 메모리 -> 하드디스크

21. 메모리 할당 알고리즘

    - First fit : 메모리의 처음부터 검사해서 크기가 충분한 첫번째 메모리에 할당
    - Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾음
    - Best fit : 모든 메모리 공간을 검사해서  <u>내부 단편화를 최소화</u>하는 공간에 할당

22. 페이지 교체 알고리즘에 따른 페이지 폴트 방식

    - 페이지 교체 : 가상 메모리를 통해 조회한 페이지는 다시 사용될 가능성이 높다. 페이지 교체를 위해서는 실제 메모리에 존재하는 페이지를 가상 메모리로 저장한 후, 가상 메모리에서 조회한 페이지를 실제 메모리로 로드해야 한다. 그렇다면 어떤 실제 메모리 페이지를 가상 메모리로 희생시킬 것이냐에 대해 다음 알고리즘들로 정한다.
    - OPT : 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 (실현 가능성 희박)
    - FIFO : 메모리가 할당된 순서대로 페이지를 교체
    - LRU : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
    - LFU : 사용 빈도가 가장 적은 페이지를 교체
    - NUR : 최근에 사용하지 않은 페이지를 교체

23. 페이지 폴트 

24. 외부 단편화와 내부 단편화란?
    - 외부 단편화: 실행할 작업보다 많은 메모리 공간이 남아있지만 배치할 수 없는 경우 . 메모리 배치에 따라 발생하는 문제 -> 해결: 페이징
    - 내부 단편화: 작업에 필요한 공간보다 많은 공간을 할당받아서 내부의 사용 불가능한 공간 - > 해결 : 세그멘테이션 (가변 분할 할당)

25. 가상 메모리
    - 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식
    - 실제 RAM (주기억장치)보다 큰 메모리 영역 제공
    - 크게 세그먼트 방식과 페이징 방식이 있다.

26. 페이징
    - 논리 주소 공간(가상 메모리)를 동일한 크기의 페이지로 자르고, 물리적 주소 공간(RAM)을 동일 크기의 프레임으로 잘라서 배치한다.
    - 외부 단편화 해결: 연속적이지 않은 공간도 활용할 수 있다.
    - 주소의 동적 재배치 허용 : 페이지와 프레임을 대응시키기 위해 page mapping이 필요해서 paging table이 필요하다. (MMU - 메모리 관리장치 필요)
    - 페이지 단위에 알맞게 꽉채워 쓰는게 아니므로 내부 단편화 문제는 여전히 있다. 페이지가 클수록 내부 단편화도 커짐. 그러나 페이징 단위를 작게 하면 page mapping 과정이 많아져 오히려 효율이 떨어진다.

27. 세그먼테이션

    - 내부 단편화 해결
    - 사용자/프로그래머 관점의 메모리 관리 기법
    - 세그먼테이션은 논리적단위 (세그먼트)로 나누어 메모리를 사용하는 시점에 할당된다.
    - 각 세그먼트는 연속적인 공간에 저장되어 있다. 
    - 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다
    - mapping을 위해 세그먼트 테이블이 필요하며 각 세그먼트 항목별 세그먼트 시작 주소와 길이 정보를 가지고 있다. 
    - 프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부 단편화를 해결할 수 있으나 여전히 중간에 프로세스가 메모리를 해제하면 구멍이 생겨 외부 단편화 문제가 발생한다.

28. Swapping의 뜻과 사용 이유는?

    스와핑은 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치로 보내고 다른 프로세스의 메모리를 불러 들이는 메모리 관리 기법이다. 주 기억 장치로 불러오는 과정을 Swap-in, 보조 기억 장치로 내보다는 과정을 Swap-out이라고 한다.

    스와핑은 메모리에 존재하는 프로세스의 수, 즉 다중 프로그래밍의 정도를 조절한다. 너무 많은 프로그램이 메모리에 동시에 올라오면 프로세스당 할당되는 메모리 양이 적어져 시스템 전체의 성능이 크게 떨어지기 때문에 스와핑을 통해 몇몇 프로그램을 디스크의 스왑 영역으로 보낸다.

29. 외부 단편화 해결책으로 꼽히는 통합과 압축에 대해 설명하고 차이점을 논하시오.

    통합은 빈 공간들의 주소가 인접한 경우 통합하여 매우 작은 공간들이 여러 개 발생하는 것을 막는 방법이다.

    압축은 모든 빈 공간들을 한 곳으로 합쳐 하나의 빈 영역으로 생성하는 방법이다.

    통합은 연속된 공간들을 합병하지만 압축은 재배치를 통해 비연속적으로 흩어져 있는 공간들을 합병한다. 따라서 압축 기법은 단편화를 없애는 좋은 방법이 될 수 있지만 비용이 크기 때문에 비경제적이다.

30. 요구 페이징 기법의 페이지 부재 처리 과정을 설명하시오.

    요구 페이징 기법은 프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는게 아니라, 당장 사용될 페이지만을 올리는 방법이다. 이때 CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않는 경우를 페이지 부재 (page fault)라고 하며 이때 유효-무효 비트는 무효로 세팅되어 있다.

    1)   CPU가 무효 페이지에 접근하면 MMU는 페이지 부재 트랩 (page fault trap)을 발생시키며 CPU 제어권이 커널 모드로 전환됩니다.

    2)   커널 모드에서 page fault handler가 호출되며, 이때 호출된 페이지가 invalid한 경우 (잘못된 주소를 가지거나 잘못된 접근인 경우)에는 프로세스가 종료됩니다.

    3)   i. Valid한 페이지일 경우 물리적 메모리에 비어있는 프레임 (free frame)을 할당받아 그 공간에 해당 페이지를 읽어옵니다.

    ii. 비어있는 프레임이 없다면 페이지 하나를 디스크로 스왑 아웃 시킨 후 페이지를 읽어옵니다.

    4)   요청된 페이지가 디스크로부터 메모리로 적재되기 까지, 페이지 폴트를 발생시킨 프로세스는 PCB에 CPU 레지스터 상태 및 프로그램 카운터값을 저장해둔 후 CPU를 빼앗기고 block됩니다.  

    5)   디스크 입출력이 완료되어 인터럽트가 발생하면 페이지테이블에서 해당 페이지로의 유효-무효 비트를 유효로 변경하고 block해뒀던 프로세스를 ready queue로 이동시킵니다.

    6)   이 프로세스가 다시 CPU를 할당받으면 PCB에 저장해둔 값을 복원시켜 중단되었던 명령부터 실행됩니다.

31. 스레싱의 뜻과 원인, 해결방법을 운영체제 관점에서 대해 설명하시오.

    스레싱이란 메모리 영역에 접근할 때 페이지폴트율이 높아 성능이 저하되는 상태다. 스레싱은 다중 프로그래밍 정도가 높거나 효율적이지 못한 페이지 교체 방법을 사용할 경우 발생한다.

    스레싱을 해결하기 위한 방법으로는 워킹셋 모델과 PFF 등이 있다.

    워킹셋 모델이란 지역성을 기반으로 가장 많이 쓰이는 페이지 집합을 메모리 공간에 계속 상주시켜 스레싱을 줄이는 방법이다.

    PFF (Page Fault Frequency)란, 페이지 폴트 빈도를 조절하는 방법으로 페이지폴트가 상한선, 하한선 이내에서 발생하도록 유지하는 방법이다. 페이지폴트 발생 횟수가 상한선을 초과할 경우 프레임 할당을 늘려주며, 반대로 하한선 미만일 경우엔 프레임을 회수하여 줄여준다.