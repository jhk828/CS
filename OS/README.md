# 운영체제

1. Process와 Thread의 차이

   - 프로세스는 메모리에 올리와 실행되고 있는 프로그램

   - 스레드는 프로세스 안에서 실행되는 흐름 단위

   - 프로세스는 최소 하나의 스레드를 보유하고 있으며, 각각 별도의 주소 공간을 독립적으로 할당받는다. (code, data, heap, stack)

     - 프로세스들은 독립적이기 때문에 통신하기 위해 IPC를 사용해야 한다.

   - 스레드는 프로세스의 코드, 데이터, 힙 영역을 공유하고 별도의 스택 영역을 갖는다.

     - Stack을 분리한 이유는 Stack에는 함수의 호출 정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위함이다.

     ![Process구조.JPG](https://github.com/jhk828/CS/blob/master/img/Process%EA%B5%AC%EC%A1%B0.JPG?raw=true)

2. Process State와 상태 변환

   1. `new` (생성) : 프로세스의 작업 공간인 메인 메모리에 생성되고 운영 체제 내부에 PCB가 만들어진다. (PCB는 프로세스 실행 정보를 관리하기 위해 생성됨)
   2. `ready`(준비) : 프로세서에(CPU)게 할당 받기를 기다린다.
   3. `running` : 프로세서를 점유하여 명령어들이 실행된다.
   4. `waiting` (대기) :  이벤트 (I/O 종료 등 외부 신호)가 일어나길 기다린다.
   5. `terminated` : 프로세스 수행이 끝난다. 할당된 자원을 OS에 돌려주고 관련 PCB가 삭제된다.

3. Process 상태 변환

   1. `dispatching`: ready 프로세스는 scheduler dispatcher에 의해 프로세서가 부여되어 running 상태가 된다. (ready -> running)

   2. `time run out` : 어떤 프로세스가 프로세서를 독점하는 것을 막기 위해 운영체제는 인터럽트 클록을 두어 지정된 시간 동안만 프로세스가 프로세서를 점유하도록 만든다. (running -> ready)

   3. `block`: running 프로세스가 지정된 시간 이전에 입출력 연산 등을 필요로 할 경우 그 프로세스는 스스로 프로세서를 양도한다. (running-> waiting)

   4. `wakeup` : 입출력 작업이 끝나면 대기 상태의 프로세스는 준비 상태로 변한다. (waiting -> ready)

   ![ProcessState.JPG](https://github.com/jhk828/CS/blob/master/img/ProcessState.JPG?raw=true)

   

4. PCB란

   - Process Control Block, 프로세스 제어 블록
   - 프로세스에 대한 중요한 정보를 저장하고 있으며 프로세스 생성 시 만들어지며 주기억장치에 유지된다.
   - 문맥전환 등 다른 프로세스를 처리해야 할 때 PCB에 현재 상태를 저장하고 그 작업 상태를 불러와 작업 재개가 가능해진다.
   - PID, 상태, 다음 명령어 주소가 저장된다.

5. 멀티 스레드란

   - 하나의 응용 프로그램을 여러 개의 스레드로 구성하고, 각 스레드로 하여금 하나의 작업을 처리하도록 한다.
   - 웹 서버는 대표적인 멀티 스레드 응용 프로그램이다.

6. 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?

   - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 감소함
   - 프로세스 간의 통신 (IPC)보다 스레드 간의 통신 비용이 적다
   - 대신 멀티 스레드 사용 시 공유 자원으로 인한 문제 해결을 위해 동기화에 신경써야 한다.

7. 멀티 프로세싱과 멀티 프로그래밍의 차이는?

   - 멀티 프로세싱은 여러 개의 처리 장치 (CPU)를 장착하여 동시에 여러 작업을 병렬로 실행한다.
   - 멀티 프로그래밍은 다수 개의 프로그램이 같이 주기억장치에 있도록 한 방식
   - CPU 코어의 관점에서 생각
     CPU 코어 여러개로 프로세스를 여러개 수행한다 -> 멀티 프로세싱
     CPU 코어 하나로 프로세스를 여러개 수행한다 -> 멀티 프로그래밍
     CPU 코어 몇 개를 쓰던 간에 작업을 수행한다 (프로세스보다 확장된 의미) -> 멀티 태스킹

8. [CPU 스케줄링](https://github.com/jhk828/CS/blob/master/img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81.JPG)

   - 스케줄러란 CPU와 같은 자원을 우선순위에 기반하여 프로세스에 할당하는 방법을 말한다. 그 Queue에는 세 가지가 있다.
   - Job Queue : 현재 시스템 안에서 돌고 있는 프로세스의 집합
   - Ready Queue : 메모리 안에서 CPU의 할당을 기다리는 프로세스의 집합
   - Device Queue : 장치 입출력을 기다리고 있는 프로세스의 집합

9. 스케줄러 종류 세 가지

   - 장기 스케줄러 (잡 스케줄러) : 프로세스가 한꺼번에 많이 올라올 시, 메모리와 디스크 사이에서 메모리에, Ready Queue에 어떤 걸 집어넣을지 결정
   - 단기 스케줄러 (CPU 스케줄러) : CPU와 메모리 사이에서 Ready Queue에 있는 프로세스 중 어떤 것을 CPU 할당을 받게 할지 스케줄링
   - 중기 스케줄러 (Swapper) : 여유공간 부족 시 공간을 만들기 위해 메모리에서 쫓아내어 디스크로 옮김, 동시에 메모리가 많이 올라가는 것을 조절

10. **Context Switching**이란?

   - 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정
   - 현재 실행중인 프로세스의 상태 (Context)를 먼저 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 다시 복구한다.

11. 인터럽트란?

    - CPU가 프로세스를 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요함을 CPU에게 알리는 것
    - 인터럽트 종류
      - I/O Request : 입출력 요청
      - Time Slice Expired : CPU 사용시간 만료
      - Fork Child : 자식 프로세스 생성
      - Wait for interrupt : 인터럽트 처리 대기
    - 컨텍스트 스위칭 시 CPU는 아무런 작업을 하지 못한다. 따라서 잦은 컨텍스트 스위칭은 성능 저하를 일으킴.

12. 뮤텍스와 세마포어란, 차이점은?

    - 뮤텍스는 Locking 메커니즘. 락을 건 쓰레드만이 임계 영역을 나갈 때 락 해제 가능
    - 세마포어는 Signaling 메커니즘. 락을 걸지 않은 쓰레드도 sinal을 사용하여 락 해제 가능
      - 세마포어 카운트 = 1 설정 시 뮤텍스처럼 사용 가능
    - 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다.
    - 세마포어는 소유 불가능하지만 뮤텍스는 소유가 가능하다.
    - 동기화의 개수가 다르다.

13. Race Condition
    - 두 개의 스레드가 하나의 자원을 놓고 서로 사용하려고 경쟁하는 상황
    - 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 실행 순서를 조절해주지 않으면 결과값에 영향을 줄 수 있다.

14. 교착상태란?

    - 한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황
    - 프로레스가 자원을 얻기 위해 영구적으로 기다리는 상태

15. 교착상태 발생 조건

    1. Mutual Exclusion 상호배제 : 한 자원은 한번에 한 프로세스만 사용 가능
    2. Hold and Wait 점유 대기: 프로세스는 자원이 할당된 상태에서 다른 자원이 할당되기를 기다린다.
    3. No preemption 비선점 : 다른 프로세스가 사용 중인 자원을 선점하여 사용할 수 없다.
    4. Circular Wait 환형 대기: 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있다.

16. 교착상태 해결법

    1. 예방 : 4가지 조건 중 하나를 제거해서 데드락을 미리 예방
    2. 회피 : 자원이 어떻게 요청될지에 대한 정보를 미리 알아서, 데드락에 빠질 가능성이 있는지 운영체제가 검사를 해서 빠질 가능성이 없을 대만 자원을 할당하여 문제를 회피한다.
       - 은행원 알고리즘
    3. 발견 & 회복 : 교착 상태가 해결될 때 까지 한 프로세스씩 중지
       - 운영체제가 요청하는 자원을 모두 주고 주기적으로 데드락에 빠졌는지를 검사한다. 데드락에 빠진 것을 발견 (detect)하면, deadlock에 빠지기 전 상태로 회복(recover)
       - 강제로 프로세스/ 스레드 들 중 하나를 종료시켜서 강제로 자원 할당을 해제한다.
       - 발견 : 자원 할당 그래프, 복구 : 선점, 프로세스 중지 (희생자 선택)
    4. 무시

17. 메모리 계층 : 캐시 -> 메모리 -> 하드디스크

18. 메모리 할당 알고리즘

    - First fit : 메모리의 처음부터 검사해서 크기가 충분한 첫번째 메모리에 할당
    - Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾음
    - Best fit : 모든 메모리 공간을 검사해서  <u>내부 단편화를 최소화</u>하는 공간에 할당

19. 페이지 교체 알고리즘에 따른 페이지 폴트 방식

    - 페이지 교체 : 가상 메모리를 통해 조회한 페이지는 다시 사용될 가능성이 높다. 페이지 교체를 위해서는 실제 메모리에 존재하는 페이지를 가상 메모리로 저장한 후, 가상 메모리에서 조회한 페이지를 실제 메모리로 로드해야 한다. 그렇다면 어떤 실제 메모리 페이지를 가상 메모리로 희생시킬 것이냐에 대해 다음 알고리즘들로 정한다.
    - OPT : 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 (실현 가능성 희박)
    - FIFO : 메모리가 할당된 순서대로 페이지를 교체
    - LRU : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
    - LFU : 사용 빈도가 가장 적은 페이지를 교체
    - NUR : 최근에 사용하지 않은 페이지를 교체

20. 페이지 폴트 

21. 외부 단편화와 내부 단편화란?
    - 외부 단편화: 실행할 작업보다 많은 메모리 공간이 남아있지만 배치할 수 없는 경우 . 메모리 배치에 따라 발생하는 문제 -> 해결: 페이징
    - 내부 단편화: 작업에 필요한 공간보다 많은 공간을 할당받아서 내부의 사용 불가능한 공간 - > 해결 : 세그멘테이션 (가변 분할 할당)

22. 가상 메모리
    - 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식
    - 실제 RAM (주기억장치)보다 큰 메모리 영역 제공
    - 크게 세그먼트 방식과 페이징 방식이 있다.

23. 페이징
    - 논리 주소 공간(가상 메모리)를 동일한 크기의 페이지로 자르고, 물리적 주소 공간(RAM)을 동일 크기의 프레임으로 잘라서 배치한다.
    - 외부 단편화 해결: 연속적이지 않은 공간도 활용할 수 있다.
    - 주소의 동적 재배치 허용 : 페이지와 프레임을 대응시키기 위해 page mapping이 필요해서 paging table이 필요하다. (MMU - 메모리 관리장치 필요)
    - 페이지 단위에 알맞게 꽉채워 쓰는게 아니므로 내부 단편화 문제는 여전히 있다. 페이지가 클수록 내부 단편화도 커짐. 그러나 페이징 단위를 작게 하면 page mapping 과정이 많아져 오히려 효율이 떨어진다.

24. 세그먼테이션

    - 내부 단편화 해결

    - 사용자/프로그래머 관점의 메모리 관리 기법
    - 세그먼테이션은 논리적단위 (세그먼트)로 나누어 메모리를 사용하는 시점에 할당된다.
    - 각 세그먼트는 연속적인 공간에 저장되어 있다. 
    - 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다
    - mapping을 위해 세그먼트 테이블이 필요하며 각 세그먼트 항목별 세그먼트 시작 주소와 길이 정보를 가지고 있다. 
    - 프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부 단편화를 해결할 수 있으나 여전히 중간에 프로세스가 메모리를 해제하면 구멍이 생겨 외부 단편화 문제가 발생한다.



## Page Fault와 페이지 요구 과정 

in 가상메모리

1. 페이지 테이블을 검사하여 필요로 하는 페이지의 메모리 참조가 `valid` 한지 `not valid` 한지 판단한다.
2. `invalid` 상태라면 운영체제에 `trap`을 건다. 운영체제는 `invalid`한 경우가 메모리 경계를 넘는 것이라면 프로그램을 종료시키고, `page falut`라면 `free frame`을 찾는다.
3.  디스크에서 해당 페이지로 로딩하라고 I/O 요청을 하며, 프로세스를 `waiting` 상태로 바꾼다.
4. 페이지가 `free frame`에 로딩 완료되었다는 인터럽트가 오면 페이지 테이블에 접근해서 상태를 `invalid`에서 `valid`로 변경한 후, 프로세스를 `waiting`에서 `ready`로 바꾼다.
5. `page fault`를 야기했던 인스트럭션부터 다시 수행한다.