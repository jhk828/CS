# Database

## DB 용어

### ◼ Table

- 행과 열로 이루어진 데이터의 집합을 테이블이라고 한다.
- 관계형 데이터베이스에서는 테이블에 제약을 추가해 relation이라고 한다.

### ◼ Relation 조건

1. 모든 값은 유일한 값을 가진다.
2. 하나의 릴레이션에서 중복되는 행이 존재하면 안된다.

### ◼ Row = Tuple = Record

### ◼ Column = Attribute

- 열을 구성하는 값들은 같은 Domain으로 되어 있다.
- 필드 : 열에 해당하는 가장 작은 단위의 데이터

### ◼ Domain

- 필드에 채워질 수 있는 값의 집합

### ◼ Schema

- 데이터베이스의 구조와 제약조건 등 전반적인 명세 기술

- 사용자 관점에 따라 외부 / 개념 / 내부 스키마로 구분한다.

  1. 외부 스키마 : 각 사용자의 관점

  2. 개념 스키마 : 전체적 뷰, 모든 사용자들의 관점

  3. 내부 스키마 : 물리적 접근 방법, 저장 방법

<br>

## Key

#### ◼ PK, FK, ER-Model이란?

1. `Primary Key` : 테이블에서 행을 유일하게 구분
2. `Foreign Key` : 다른 테이블의 pk의 값을 반드시 참조해야 하는 key
3. `ER (Entity-Relation) Model` : 개체 관계 모델

<br>

## 정규화

#### ◼ 정규화를 하는 이유

- 데이터 중복을 허용하지 않고 <u>무결성</u>을 유지하기 위해서다. 
- 데이터를 중복하여 삽입할 시 삽입, 삭제, 갱신 이상 (anamoly)가 발생할 수 있다.

#### ◼ 정규화 과정

높은 차수의 정규형은 낮은 차수의 정규형을 모두 만족해야 한다.

1. 제1정규형 : 모든 속성 값이 원자값을 갖도록 분해
2. 제2정규형 : 기본키가 아닌 속성이 기본키에 완전함수종속성이도록 분해 (부분적함수이행제거)
   - 부분적 함수 이행  : 기본키의 부분집합이 결정자가 되는 것
3. 제3정규형 : 기본키가 아닌 속성이 기본키 직접 종속되도록 분해한다. (이행적 함수 종속 제거)
   - 이행적 함수 종속 : 회원번호를 알면 이름을, 이름을 알면 나이도 알 수 있다. 이때 회원번호를 알면 나이도 알 수 있으므로 이행적 함수 종속 관계다.
4. BCNF : 결정자이면서 후보키가 아닌 것 제거되도록 분해

![normalization](image/normalization.png)

![정규화](https://github.com/jhk828/CS/blob/master/img/%EC%A0%95%EA%B7%9C%ED%99%94.jpeg?raw=true)

### ◼ 무결성 (Integrity) 제약조건

무결성이란 DB에 저장된 값과 표현하는 현실 세계 길제값이 일치하는 정확성이다.

1. 개체 무결성 : pk 속성값은 `unique` 해야 하고(=중복값을 가질 수 없고) `null`값을 가질 수 없다.
2. 참조 무결성 : 외래키 값은 `null`이거나 참조 릴레이션의 `pk` 값과 동일해야 한다.
3. 도메인 무결성 : 속성 값이 그 속성이 정의된 도메인에 속한 값이어야 한다. (ex. 고등학생 학년은 1, 2, 3학년만)
4. 키 무결성 : 한 릴레이션에는 최소 하나의 키가 존재해야 한다.
5. 고유 무결성 : 특정 속성이 고유한 값을 가져야 한다면 그 속성값은 모두 달라야 한다.
6. null 무결성 : 특정 속성값에 null이 올 수 없을 경우 그 속성값은 null이 올 수 없다.

#### ◼ 이상 (anamoly)

정규화로 해결한다.

1. 갱신 이상 : 튜플 수정 시 중복 데이터의 일부만 수정되어 불일치 발생
2. 삽입 이상 : 데이터 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력
   - 강의를 아직 수강x 새 학생 삽입, 강의 코드 속성에 null
3. 삭제 이상 : 튜플 삭제 시 같이 저장된 정보까지 연쇄적으로 삭제됨

<br>

## 트랜잭션

#### ◼ 트랜잭션이란

작업의 논리적 단위로, 쿼리를 하나의 묶음 처리 해서 중간에 실행이 중단될 경우 처음부터 시작하는 `Rollback`과,오류없이 실행을 마치면 `Commit`하는 실행 단위다.

#### ◼ 트랜잭션 특징 4가지

1. `Atomicity` `원자성` : All or Nothing, 일부만 실행하지 않는다.
2. `Consistency` `일관성` : 트랜잭션 실행 후 일관된 DB 상태를 유지한다. ex) 데이터 타입이 정수형에서 갑자기 문자열로 변하면 안된다.
3. `Isolation` `격리성` : 서로 간섭 없이 독립적으로 수행
4. `Durability` `지속성` : 수행 후 commit을 통해 영원히 반영된다.

#### ◼ commit vs rollback

1. commit : 
2. rollback

<br>

## 인덱스

#### ◼ 인덱스 사용 이유

- 검색을 더 빠르게 하기 위해서
- <u>데이터와 데이터 위치</u>를 키와 값의 쌍으로 인덱스를 만들어 둔다.
- 원하는 값을 찾는 것은 빠르지만 새로운 값을 추가하거나 삭제, 수정할 때는 속도가 느려진다. 인덱스는 항상 정렬된 상태를 유지하기 때문이다.



#### ◼ 해시 테이블

- 주어진 키 값으로 목표 레코드 주소 계산

- 시간 복잡도 O(1), 검색이 매우 빠르다

- 부등호(<, >)와 같이 <u>순차 검색 불가</u>

  

#### ◼ B+ Tree

- B- Tree 개선

<br>

## Query

### ◼ `inner join` vs `outer join`

1. `inner join` : 교집합, 두 집합에 모두 있는 열만 남는다.
2. `left outer join` : 왼쪽의 모든 열 + 오른쪽에도 있는 공통부분 열
3. `right outer join` : 오른쪽의 모든 열 + 왼쪽에도 있는 공통부분 열
4. `full outer join` : 합집합



### ◼ `ifnull` vs `nullif`

- `ifnull(x, y)` : x가 null이면 y를 리턴, 아니면 x 리턴
- `nullif(x, y)` : x==y이면 null을, 그렇지 않으면 y를 리턴

<br>

## NoSQL

#### ◼ RDBMS (Relational DataBase Management System)

- 테이블로 이루어져 행과 열로 데이터의 관계 관리
- 장점
  1. 데이터 분류, 정렬, 탐색 속도가 빠르다.
  2. 데이터 무결성을 보장한다.
- 단점 
  1. Join이 많고 복잡한 쿼리 사용 시 수정이 어렵다
  2. 수평적 확장이 어렵고 수직적 확장만 가능해 데이터 처리량에 한계가 있다.

#### ◼ NoSQL

- 관계형 데이터 모델 지양, 스키마가 없거나 느슨한 스키마 제공
- key-value 형식, 문서형, 그래프형
- 장점 
  - 스키마가 없어 유연하다.
  - 수직, 수평적 확장이 모두 가능하다. 
  - 수평적 확장이 가능해 대량의 분산된 데이터 저장, 조회에 특화
  - 데이터가 애플리케이션이 필요로 하는 형식으로 저장, 데이터 읽는 속도가 빠르다
- 단점
  - 중복된 데이터 추가 가능, 관리 필요
  - NoSQL마다 쿼리 언어를 다르게 사용, 이식성이 낮다.

#### ◼ 수직적 vs 수평적 확장 (scaling)

1. `수직적 확장` : 단순히 데이터 베이스 서버의 성능 확장 (CPU 업그레이드 등)
2. `수평적 확장`  : 더 많은 서버가 추가되고 데이터베이스가 추가적으로 분산된다.
