# Web

1. AJAX란 무엇이며 왜 사용하는지 설명하시오
   - 비동기 통신을 위한 JavaScript 라이브러리 입니다.
   - **A**synchronous **J**avascript **A**nd **X**ml(비동기식 자바스크립트와 xml)
   - 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술

2. GET 방식과 POST 방식의 차이점을 설명하시오.

    GET 메소드는 데이터를 요청할 때 사용하며, url 파라미터에 데이터를 담아보내기 때문에 HTTP message에 body가 없다.

    POST 메소드는 서버의 리소스를 새로 생성 / 업데이트 할 때 사용하며, body에 데이터를 담아 보내 HTTP message에 body가 존재한다. GET보다 처리 속도는 느리지만 데이터가 노출되지 않는다.

3. PATCH와 PUT의 차이점을 설명하시오.

    둘 다 리소스를 업데이트 한다는 점은 동일하나, PUT은 리소스 모든 것을 업데이트 하지만 PATCH는 일부를 업데이트한다.

4. REST란 무엇이고, RESTful하게 API를 디자인한다는 것은 무엇인지 설명하시오.

   - Restful하게 API를 디자인한다는 것은 URI를 규칙에 맞게 잘 설계했는지의 여부

     1. 동일한 URI(End point)의 행위에 맞게 POST, GET, DELETE, PATCH등의 메소드를 사용한다.
     2. 명사를 사용한다. 리스트를 표현할 때는 복수형을 사용한다.
     3. URI Path에 불필요한 파라미터를 넣지 않는다. 즉, 단계를 심플하게 설계한다.

5. HTTP의 비연결성과 비상태성이란?

   1. **비연결성(Connectionless)**

      서버는 request를 보낸 클라이언트에 response를 보낸 후 연결을 끊는다.

   2. **비상태성(Stateless)**

      클라이언트와 서버가 통신으로 데이터를 주고받아도 두번째 통신에서는 이전 데이터를 유지하지 않는다.

   3. 장점

      리소스 낭비가 줄어든다.

   4. 단점

      현재 접속자가 이전 사용자와 같은 사용자인지 알 수 있는 방법이 없다. 클라이언트는 매 요청마다 인증을 해야 한다.

6. 쿠키
   - 특정 웹서버에 접속할 때 생성되는 개인 아이디, 비밀번호 등 방문 사이트 정보를 담은 임시 파일
   - 클라이언트 (브라우저) pc에 저장됨
   - text 형식
   - 이름, 값, 유효 시간, 경로, Secure (https protocol인 경우만 전송), HttpOnly (script로 get 불가 여부)
   - 서버에 요청 (request GET, POST) 할 때 Cookie를 넘겨준다.
   - 만료 시점이 지나야 삭제됨
   - 세션보다 빠름
   - 보안성이 떨어진다.
   - 사용 목적 : 세션 관리, 개인화, 트래킹

7. 세션

   - 클라이언트 - 웹 서버 간 네트워크 연결이 지속적으로 유지되고 있는 상태
   - 웹 서버 저장됨
   - object 형식
   - 브라우저 종료 시 삭제
   - 쿠키보다 느림
   - 쿠키보다 보안성이 좋고 주로 로그인 정보 유지에 사용된다.

8. 세션/쿠키 방식 단점

   1. 메모리 부족하거나 서버가 재부팅되면 날아간다. (휘발성)

   2. Session ID를 모든 서버에서 이용할 수 있도록 하기엔, 중앙 세션 저장소가 없다면 어려워 확장이 어렵다.

      이 세션을 redis같은 MemCached같은 메모리형 데이터베이스 서버에 저장하기도 한다.

9. access token이란

    HTTP 통신은 stateless하기 때문에 이전 통신에서 이미 인증이 진행되었는지 알 수 없다. 따라서 통신을 할 때 해당 HTTP 요청을 처리하기 위해 로그인 정보 등 필요한 데이터를 첨부해서 요청을 보내야 한다. 로그인 정보를 담고있는 데이터가 access token이다.

10. JWT (Json Web Token / 인가 토큰 방식)

    access token을 생성하는 방법 중 가장 널리 사용되는 기술로, json 데이터를 token으로 변환하는 방식이다. 사용자가 로그인 하면 토큰을 생성해서 클라이언트로 넘겨주고 서버가 토큰을 기억하고 있지 않다.

    json 데이터를 토큰화 시키는 이유는 json 데이터를 사용하면 해킹 가능성의 문제가 생기기 때문이다. 토큰은 누군가가 해킹 목적으로 가짜 JWT를 전송해도 API 서버에서 자신이 생성한 JWT인지 아닌지 확인하는 기능을 제공한다.

    인코딩, 암호화된 3가지 정보를 이어붙인다. xxx.yyy.zzz

    구조 : header, payload, verify signature(서명)

11. JWT의 장점과 단점

     추가 저장소가 필요없어 간편하다. 세션, 쿠키처럼 별도의 저장소 관리가 필요 없고 JWT는 발급한 후 검증만 하면 되기 때문에 stateless한 서버를 만드는데 강점이 된다. stateless 서버는 상태를 저장하지 않기 때문에 서버를 확장하고 유지, 보수 하는데 유리하다.

     또한 확장성이 뛰어나다. 토큰 기반의 다른 인증 시스템에 접근 가능하다.

     단점은 한 번 발급되면 유효기간이 완료될 때 까지는 수정이 불가하기 때문에 악의적 사용자가 정보 탈취 할 수 있다.

12. refresh token

     access token의 유효 기간을 짧게 하고 refresh token이라는 새로운 토큰을 발급해, access token을 탈취당해도 상대적으로 피해를 줄일 수 있다.

12. 인증과 인가

13. HTTP vs WebSocket

    - **HTTP**는
      - 유저가 request를 보내야 서버가 response로 응답할 수 있다.
      - HTTP는 `stateless`다. 서버는 response를 보내면 전에 받았던 request를 잊어버린다.
      - 서버로 메시지를 보낼 때 클라이언트 정보를 보내려면 (유저 프로필 등) `cookie`를 보내야 한다.
    - **WebSocket**은 `real-time`, `양방향 통신` 프로토콜이다.
      - 브라우저가 서버로 WebSocket request를 보낸 후 연결이 성립되면, 양방향 통신이 가능해진다. 서버는 유저에게 request 없이 메시지를 보낼 수 있다. (real-time으로 계속 연결되어 있다.)

14. 웹 서버와 WAS란

    웹 서버는 웹 브라우저 같은 클라이언트로부터 HTTP 요청을 받아 HTML과 같은 웹 페이지를 전송해주며 정적 문서만 처리한다. Apache Server, Nginx 등이 있다.

    WAS (Web Application Server는) 동적 컨텐츠 까지 제공한다. (WAS = Web Server + Web Container)

15. 웹 브라우저에 구글을 입력하면 일어나는 일

16. DNS의 뜻과 사용하는 프로토콜

     DNS는 도메인을 인터넷 주소인 IP로 바꾸며 신뢰성 보다는 속도가 중요하기에 UDP를 사용한다.

17. HTTP와 HTTPS

    - HTTP(Hypertext Transfer Protocol) + SSL(Secure Socket Layer) = HTTPS(Hypertext Transfer Protocol Secure)
    - HTTPS는 HTTP를 안전하게 만드는 방식이다.
    - HTTPS 프로토콜은 전송되는 데이터를 암호화해서 보냄으로써, 데이터 노출의 안전이 보장된다.
    - HTTPS는 TCP 계층 위에 SSL 또는 TLS 보안계층이 추가된다.

18. HTTPS의 암호화 방식

    공개키 암호화 방식과, 공개키의 느리다는 단점을 보완한 대칭키 암호화 방식을 함께 사용한다.

    공개키 방식으로 대칭키를 전달하고, 서로 공유된 대칭키를 가지고 통신한다.

19. SSL/TLS 인증 과정을 비대칭 알고리즘과 관련지어서
    1. 인터넷 사이트 (서버)는 공개키와 개인키를 만들고, 신뢰할 수 있는 인증기관 (CA)에 자신의 정보와 공개키를 관리해 달라고 계약한다.
    2. 인증 기관은 기관만의 공개키와 개인키가 있다. 인증 기관은 사이트가 제출한 데이터를 검증하고, 인증 기관의 <u>개인키로 사이트 정보를 암호화해서 인증서</u>를 만들어 제공한다. 사이트는 인증서를 가지게 되었다.
    3. 인증기관은 <u>웹 브라우저에게 인증기관의 공개키</u>를 제공한다.
    4. 사용자가 사이트에 접속하면 서버는 자신의 인증서를 웹 브라우저(클라이언트)에 보낸다.
    5. 웹 브라우저는 3에서 알고 있던 인증기관의 공개키로 인증서를 해독하여 검증한다. 그러면 사이트의 정보와 서버의 공개키를 알 수 있게 된다. (보안상의 의미는 없지만 해당 서버로부터 온 응답임을 확신하는 과정)
    6. 5에서 얻은 서버의 공개키로 대칭키를 암호화해서 다시 사이트로 보낸다.
    7. 사이트는 개인의 암호문을 해독해 대칭키를 얻게 되고, 이제 대칭키로 데이터를 주고받을 수 있게 된다.

