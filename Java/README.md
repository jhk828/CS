# Java

#### ◼ Java 데이터 메모리 영역

JVM이 실행되면 OS가 JVM에 필요한 메모리를 할당해준다. JVM은 OS로부터 받은 메모리를 나누어 관리한다. -> Runtime Data Area

1. Method / Class 영역
   - 어떤 메소드가 호출되려면 그 메소드를 갖고 있는 클래스 파일이 메모리에 로딩되어 있어야 한다. 그래서 클래스를 실행할 때 `.class` 파일을 찾아서 메모리에 로딩한다.
2. Static 영역
   - 하나의 Java 파일을 필드, 생성자, 메소드로 구분하는데 필드 부분에 선언된 전역 변수, 정적 멤버 변수를 Static 영역에 저장한다.
   - 프로그램 시작부터 종료까지 메모리에 남아있는다.
3. Stack 영역
   - 매개변수, 지역 변수
   - 컴파일 시 메모리를 할당한다.
   - 메소드 내에서 정의하는 기본 자료형에 해당하는 지역변수의 데이터값이 저장된다.
   - 해당 메소드가 호출될 때 메모리에 할당되고 종료되면 해제된다.
4. Heap 영역
   - new로 생성된 객체
   - 변수 (객체, 객체변수, 참조변수)는 Stack 영역 공간에 실제 데이터가 저장된 Heap 영역의 참조값 (메모리 저장된 주소를 연결해주는 값)을 new 연산자로 리턴받는다.
   - 실제 데이터를 갖고 있는 Heap 영역의 참조값을 Stack 영역의 객체가 갖고있다. 이렇게 리턴 받은 참조값을 갖고있는 객체를 통해서만 해당 인스턴스를 핸들할 수 있다.

#### ◼ 기본 자료형 vs 참조 자료형

- 데이터 기본 자료형
  - 실제 값 저장하는 공간
  - byte, short, int, long, float, double, char, boolean
- 데이터 참조형
  - String은 기본형이 아니라 참조형이다.
  - 변수에 객체가 아니라 메모리상의 객체 주소가 저장된다.

#### ◼`Wrapper` 클래스

- 기본 자료형을 참조형화 해놓은 클래스, 주로 `java.lang` 패키지에 선언되어 있다.
- 기본 -> Boxing -> 참조형, 반대는 UnBoxing
- 특정 메소드에서 참조 자료형을 인자로 받거나, 기본 자료형이 아닌 객체 자료형으로 저장해야 할 경우, 객체 간 비교가 필요할 경우 사용
- 기본 data 타입은 객체가 아니어서 Object로 받는 다형성을 지원할 수가 없다.

#### ◼ Generic

- 클래스에서 사용할 타입을 클래스 외부에서 설정하는 것
- 만들어져 있는 클래스를 내가 원하는 형태로 사용할 수 있다.
- `< >` 안에 들어갈 수 있는 것은 참조 자료형 (클래스, 인터페이스, 배열) 뿐. 기본 자료형을 사용하기 위해선 `Wrapper` 클래스를 사용해야 한다.



#### ◼ `equals`와 `hashCode`

Java의 Hash Code란, 객체를 식별할 수 있는 유니크한 값이다. 메모리에 생성된 객체의 주소를 정수로 변환한 형태로 이 정수는 중복되지 않는 고유값이다.

동일한 객체는 동일한 메모리 주소를 갖기 때문에 동일한 해시 코드를 가져야 한다. 따라서 equals 메소드를 오버라이드 한다면 hashCode도 오버라이드 하여 객체가 논리적으로 일치하는지 확인하는 용도로 사용되어야 한다.

1. `equals()`를 재정의(`override`)할 때는, `hashCode()`도 재정의해야 한다. (항상 함께 재정의)

2. `equals()`의 값이 `true`이면, `hashCode()`도 동일한 값을 가져야 함

3. 반대로 `equals()` 값이 `false`이면, `hashCode()`도 다른 값을 가져야 함

   

#### ◼  `equals`vs `==` 연산자

`==` 연산은 주소값을 비교하는 연산자다. String은 new를 사용해 새롭게 인스턴스를 만들어 메모리에 올려 서로 다른 주소값을 참조하기 때문에 내부의 값을 비교하기 위해서는 재정의된 `equals` 매소드를 사용해야 한다.



#### ◼ `String` vs `StringBuffer` vs `StringBuilder`

- `String`은 new 연산자로 새로 생성되면 메모리 공간이 절대 변하지 않으므로, `+`, `concat`과 같은 연산 시 메모리 내용이 변하는 것이 아니라 String 인스턴스가 생성된다. 새로운 문자열이 만들어지면 기존의 문자열은 가비지 콜렉터에 의해 제거되어야 한다. 문자열 연산이 많아지면 성능이 떨어지나, 불변하기 때문에 조회가 빠르고 멀티 스레드 환경에서 동기화를 신경 쓸 필요가 없다.
- `StringBuffer`와 `StringBuilder`는 클래스는 한 번만 만들고 메모리의 값을 변경시켜서 문자열을 변경한다. 문자열 연산이 자주 있을 때 사용하면 좋다.
- `StringBuffer`는 멀티 스레드 환경에서 `synchronize` 키워드가 가능해 동기화가 가능하다. `StringBuilder`는 동기화를 지원하지 않기 때문에 멀티 스레드 환경에 적합하지 않다.



#### ◼ `Java`의 멀티 쓰레드와 `synchronize` 키워드



#### ◼ `static`의 의미

- 정적 멤버는 메모리 공간 할당 시 처음 설정된 메모리 공간이 변하지 않는다.
- 객체를 생성하지 않고도 사용할 수 있는 필드와 메소드다. 