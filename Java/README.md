# Java



`equals`와 `hashCode`

Java의 Hash Code란, 객체를 식별할 수 있는 유니크한 값이다. 메모리에 생성된 객체의 주소를 정수로 변환한 형태로 이 정수는 중복되지 않는 고유값이다.

동일한 객체는 동일한 메모리 주소를 갖기 때문에 동일한 해시 코드를 가져야 한다. 따라서 equals 메소드를 오버라이드 한다면 hashCode도 오버라이드 하여 객체가 논리적으로 일치하는지 확인하는 용도로 사용되어야 한다.

1. `equals()`를 재정의(`override`)할 때는, `hashCode()`도 재정의해야 한다. (항상 함께 재정의)

2. `equals()`의 값이 `true`이면, `hashCode()`도 동일한 값을 가져야 함

3. 반대로 `equals()` 값이 `false`이면, `hashCode()`도 다른 값을 가져야 함

   

`equals`vs `==` 연산자

`==` 연산은 주소값을 비교하는 연산자다. String은 new를 사용해 새롭게 인스턴스를 만들어 메모리에 올려 서로 다른 주소값을 참조하기 때문에 내부의 값을 비교하기 위해서는 재정의된 `equals` 매소드를 사용해야 한다.



`String` vs `StringBuffer` vs `StringBuilder`

- `String`은 new 연산자로 새로 생성되면 메모리 공간이 절대 변하지 않으므로, `+`, `concat`과 같은 연산 시 메모리 내용이 변하는 것이 아니라 String 인스턴스가 생성된다. 새로운 문자열이 만들어지면 기존의 문자열은 가비지 콜렉터에 의해 제거되어야 한다. 문자열 연산이 많아지면 성능이 떨어지나, 불변하기 때문에 조회가 빠르고 멀티 스레드 환경에서 동기화를 신경 쓸 필요가 없다.
- `StringBuffer`와 `StringBuilder`는 클래스는 한 번만 만들고 메모리의 값을 변경시켜서 문자열을 변경한다. 문자열 연산이 자주 있을 때 사용하면 좋다.
- `StringBuffer`는 멀티 스레드 환경에서 `synchronize` 키워드가 가능해 동기화가 가능하다. `StringBuilder`는 동기화를 지원하지 않기 때문에 멀티 스레드 환경에 적합하지 않다.



`Java`의 멀티 쓰레드와 `synchronize` 키워드



`static`의 의미

정적 멤버는 메모리 공간 할당 시 처음 설정된 메모리 공간이 변하지 않는다.

객체를 생성하지 않고도 사용할 수 있는 필드와 메소드다. 